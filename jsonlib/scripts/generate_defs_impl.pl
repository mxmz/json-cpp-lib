use strict;
use warnings;
use v5.10;
use JSON::XS qw( decode_json );
use Getopt::Long;



my $cast_func = "cast_value";
my $to_struct_function = "to_struct";
my $struct_type = "STRUCT_TYPE";

GetOptions ( 
        'convert-value-template-function=s' => \$cast_func, 
        'to-struct-function=s' => \$to_struct_function ,
        'struct-type=s' => \$struct_type,
        );


my $defs = decode_json( join '', <STDIN> );

print "/* Generated by $0. */\n";
print "/* DO NOT EDIT. Changes will be overwritten. */\n";
print_base_definitions($defs);
print_definitions($defs);


sub print_base_definitions {
  my ( $defs ) = shift;
  my @classes = @{ $defs->{'classes'} };

  my $defs_string;
  open my $defs_out, ">", \$defs_string;

  my @type_enums;
  my $enumclass = "enum_".(int rand(9000)+1000). "_t";

  print $defs_out "namespace interface {\n\n";

  foreach my $class ( @classes ) {
    my $class_id = $class->{"name"};
    my $defbase = $class->{'base'}; 
    
    my @members = @{ $class->{'members'} } ;

    my $base = $defbase;


    print $defs_out "class $class_id";
    print $defs_out ": public $base " if $base;
    print $defs_out " {\n";
    print $defs_out " public:\n";

    foreach my $member ( @members ) {
        $member->{"key"} //= $member->{"name"};
        $member->{"name"} =~ tr/A-Za-z_0-9/_/cs;
    }
    foreach my $member ( @members ) {
        my $id = $member->{"name"};
        my $type = get_cpp_type($member->{"isa"})->[0];
        print $defs_out "   virtual const $type &    get_$id() const = 0;\n";
    }
    my $type_enum = $class_id;
    $type_enum =~ s/(^|_)(\w)/uc$2/ge;
    push @type_enums , $type_enum;
    print $defs_out "   virtual $struct_type to_struct() const = 0;\n";
    print $defs_out "   virtual const char*  type_name() const { return \"$class_id\";}\n";
    print $defs_out "   virtual $enumclass   type() const { return $type_enum;}\n";
    print $defs_out "   virtual ~$class_id() {}\n";

    print $defs_out "}/*$class_id*/;\n";
    print $defs_out "class array_of_$class_id {\n";
    print $defs_out " public:\n";
    print $defs_out " virtual const $class_id& operator[](size_t idx ) const = 0; \n";
    print $defs_out " virtual size_t           size() const = 0;\n";
    print $defs_out " virtual ~array_of_$class_id() {}\n";
    print $defs_out "}; /*array_of_$class_id*/\n";

  }
  print $defs_out "\n}/*end ns base*/\n\n";
  print $defs_out "\n\n\n";

  print "enum $enumclass {\n    " .( join(",\n    ",@type_enums) ) . "\n};\n";
  print $defs_string;
}


sub print_definitions {
  my ( $defs ) = shift;
  my @classes = @{ $defs->{'classes'} };

  my $defs_string;
  my $decl_string;
  my $impl_string;
  open my $defs_out, ">", \$defs_string;
  open my $decl_out, ">", \$decl_string;
  open my $impl_out, ">", \$impl_string;

#    print $impl_out " template < class RetT, class ObjT >\n";
#    print $impl_out "  RetT to_struct( const ObjT& obj ) { return std::move(RetT(obj)); }\n";

  my %class_members = ( _ => [] );

  foreach my $class ( @classes ) {
    my $class_id = $class->{"name"};
    my $defbase = $class->{'base'} // "_";

    my @members = ( @{ $class_members{$defbase}  }, 
        @{ $class->{'members'} } );

    $class_members{$class_id} = \@members;

    my $base = undef;

    print $defs_out "class $class_id";
    print $defs_out ": public interface::$class_id\n";
    print $defs_out " {\n";

    foreach my $member ( @members ) {
        $member->{"key"} //= $member->{"name"};
        $member->{"name"} =~ tr/A-Za-z_0-9/_/cs;
        my $id = $member->{"name"};
        my $type = get_cpp_type($member->{"isa"})->[0];
        print $defs_out "    $type    _$id;\n";
    }

    #ctor
    print $defs_out " public:\n";
    print $defs_out "   $class_id ( $struct_type& args ) ;\n";

    print $impl_out "$class_id"."::$class_id ( $struct_type& args ) :\n";

    if ( $base) {
            print $impl_out "    $base( args ),\n";
    }

    print $impl_out join ",\n", map {
            my $id = $_->{"name"};
            my $type = get_cpp_type($_->{"isa"})->[1];
            my $key = $_->{"key"}; 
            my $validator = $_->{"check"} // "std::move"; 
            "     _$id( std::move( $validator( $cast_func< $type >( args[\"$key\"] ) ) ) ) "
        } @members;
    
    print $impl_out "\n";
    print $impl_out "{\n}\n\n";
    

    print $impl_out "$class_id"."::$class_id () :\n";

    if ( $base) {
            print $impl_out "    $base(),\n";
    }

    print $impl_out join ",\n", map {
            my $id = $_->{"name"};
            my $type = get_cpp_type($_->{"isa"})->[1];
            my $key = $_->{"key"}; 
            my $init = $_->{"init"} // "$type()"; 
            "     _$id( std::move( $init ) ) "
        } @members;


    print $impl_out "\n";
    print $impl_out "{\n}\n\n";
    
    my $std_move_ctor_init_str = join ",\n    ", map { "_". $_->{'name'} . "( std::move( that._" . $_->{'name'}. ") )" } @members;
    
    print $defs_out "   $class_id ( $class_id && that );\n";
    print $defs_out "   $class_id (); \n";

    print $impl_out "$class_id"."::$class_id ( $class_id && that ) \n";
    print $impl_out "   : " ;
    if ( $base ) {
            print $impl_out "$base ( that ),";
    }
    print $impl_out "$std_move_ctor_init_str\n{\n}\n\n";
    

#    my $multi_move_ctor_args_str = join ', ', map { get_cpp_type($_->{"isa"}) . " && " . "a_" . $_->{'name'} } @members;
#    my $multi_move_ctor_init_str = join ",\n    ", map { "_". $_->{'name'} . "( std::move( a_" . $_->{'name'}. ") )" } @members;
#
#    print $defs_out "   $class_id ( $multi_move_ctor_args_str );\n";
#
#    print $impl_out "$class_id"."::$class_id ( $multi_move_ctor_args_str ) \n";
#    print $impl_out "   : $multi_move_ctor_init_str\n{\n}\n\n";


    # to_struct
    print $defs_out "   $struct_type to_struct() const;\n";
    print $impl_out "$struct_type $to_struct_function( const $class_id& obj ) {\n";
    print $impl_out "   $struct_type rv";
    if ( $base ) {
            print $impl_out " = $to_struct_function( static_cast<const $base &>( obj ) )";
    }
    print $impl_out ";\n";
    print $impl_out "   typedef  $struct_type"."::value_type value_type;\n";
    print $impl_out join "\n", map {
            my $id = $_->{"name"};
            my $type = get_cpp_type( $_->{"isa"} )->[1];
            my $key = $_->{"key"}; 
            "   rv[\"$key\"] = std::move($to_struct_function( static_cast<const $type&>( obj.get_$id() ) ) );"        
        } @members;

    print $impl_out "\n";
    print $impl_out "   return std::move(rv);\n";
    print $impl_out "}\n";
    print $impl_out "$struct_type $class_id"."::to_struct() const {\n";
    print $impl_out " return $to_struct_function(*this);\n";
    print $impl_out "}\n\n";


    foreach my $member ( @members ) {
        my $id = $member->{"name"};
        my $type = get_cpp_type($member->{"isa"})->[0];
        my $padd = ' ' x (length($type));
        my $validator = $member->{"check"} // "std::move"; 
        print $defs_out "    const $type &  get_$id() const;\n";
        print $defs_out "    void  $padd    set_$id( const $type& );\n";
        print $defs_out "    void  $padd    set_$id( $type&& );\n";
        print $impl_out "const $type &   $class_id"."::get_$id() const { return _$id; }\n";
        print $impl_out "void  $padd     $class_id"."::set_$id( const $type & v ) { _$id = $validator(v); } ;\n";
        print $impl_out "void  $padd     $class_id"."::set_$id( $type && v ) { _$id = std::move( $validator( v ) ) ; } ;\n";
    }

    print $defs_out "}/*$class_id*/;\n";

    print $decl_out "$struct_type $to_struct_function( const $class_id& obj);\n";
    print $impl_out "\n";
    print $defs_out "\n";

    print $defs_out "class array_of_$class_id : public interface::$class_id {\n";
    print $defs_out " std::vector<$class_id>    _items;\n";
    print $defs_out " public:\n";
    print $defs_out " array_of_$class_id() {}\n";
    print $defs_out " array_of_$class_id(  std::vector<$class_id> && v ) : _items( std::move(v) ) {}\n";
    print $defs_out " const $class_id& operator[](size_t idx ) const { return _items[idx]; }\n";
    print $defs_out " size_t           size() const { return _items.size(); }\n";
    print $defs_out " operator const std::vector<$class_id>& () const { return _items; }\n";
    print $defs_out "}; /*array_of_$class_id*/\n";

  }
  print "\n/*  ***   class definitions   ***  */\n\n";
  print $defs_string;
  print "\n/*  *** function declarations ***  */\n\n";
  print $decl_string;
  print "\n/*  *** function definitions  ***  */\n\n";
  print $impl_string;


}

sub get_base_members {
    
}


sub get_cpp_type {
    my ( $typespec ) = @_;
    given($typespec) {
        when('string') {
            return [ "std::string", "std::string" ];
        }
        when(/^\[([\w\_\:]+)\]$/ ) {
#                return "std::vector<".$1.">";
                return [ "array_of_$1", "std::vector<".$1.">"] ;
        }
        when(/^\w[\w\_\:]*[\w\d]$/ ) {
                return [ $typespec, $typespec ] ;
        }
        default {
                die "Invalid type specification '$typespec'\n";
        }
    }

}






